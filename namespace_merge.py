import os
import argparse

def main():
    parser = argparse.ArgumentParser(description="Generates a merged mod from several mod folders")
    parser.add_argument("-r", "--root", type=str,  default=".",  help="Location to use to create mod")
    parser.add_argument("-d", "--delete", action="store_true", help="run the script in delete mode")
    parser.add_argument("-v", "--vanilla", action="store_true",  help="exclude vanilla outfit as a part of the mod")
    parser.add_argument("-n", "--name", type=str,  default="master.ini", help="(not functional)")
    args = parser.parse_args()
    
    # run delete mode if delete argument is used
    if args.delete:
        delete_main(args.root)
        return
    
    print("\nGenshin and Star Rail Mod Merger/Toggle Creator Script Utilizing Namespaces\n")
    
    # searches for files returns if none found
    print("\nSearching for .ini files")
    ini_files = collect_ini(args.root, args.name)
    if not ini_files:
        print("Found no .ini files - make sure the mod folders are in the same folder as this script.")
        return
    # Place holder for the vanilla outfit
    ini_files = [file for file in ini_files if file is not None]  # Remove None to exclude Vanilla Outfit
    # lists all found files
    print("\nFound:")
    for i, ini_file in enumerate(ini_files):
        print(f"\t{i}:  {ini_file}")
    # Use the name of the first .ini file (without extension) as the mod's name
    first_ini_name = os.path.splitext(os.path.basename(ini_files[0]))[0]
    

    # order of merge given by sorting the list ini_files
    print("\nThis script will merge using the order listed above (0 is the default the mod will start with, and it will cycle 0,1,2,3,4,0,1...etc)")
    print("If this is fine, please press ENTER. If not, please enter the order you want the script to merge the mods (example: 3 0 1 2)")
    print("If you enter less than the total number, this script will only merge those listed.\n")
    if args.vanilla:
        print("The vanilla outfit will be removed at the end it is safe to press enter or select an order you can still include vanilla if you add it to your order\n")
    
    ini_files = get_user_order(ini_files)
    
    # the name of the namespace cause I don't want to deal with finding it
    print("\nPlease enter the name of the object this merged mod is for (no spaces)\n")
    name = first_ini_name  # Set the mod name to the first .ini's name
    
    # sets key to cycle forward
    key = 'r'
    
    # generating backup inis
    print("generating backups")
    generate_backup(ini_files)

    # Generates the namespace for the master file
    constants = f"namespace = {name}\Master\n; Constants ---------------------------\n\n"
    overrides = "; Overrides ---------------------------\n\n"

    swapvar = "swapvar"
    # adds the [Constants] section
    constants += f"[Constants]\nglobal persist ${swapvar} = 0\n"
    constants += f"global $active\n"
    constants += "global $creditinfo = 0\n"
    constants += "global persist $swimming\n"
    constants += "global persist $temp = 0\n"
    constants += "global persist $nude = 0\n"
    # adds the [KeySwap] section
    constants += f"\n[KeySwap]\n"
    constants += f"condition = $active == 1\n"
    constants += f"key = {key}\ntype = cycle\n$temp = {','.join([str(x) for x in range(len(ini_files)-1)])}\n$creditinfo = 0\n\n"
    constants += f"[KeyPressed]\ncondition = $active == 1\nkey = {key}\ntype = hold\n$nude=1\n$creditinfo = 0\n\n"

    # adds the [Present] section to not swap when character is not active
    constants += f"[Present]\n"
    constants += f"$swimming = $\global\\tracking\swimming\npost $active = 0\nif $swimming == 0\n\t${swapvar} = $temp\n\tendif\nelse if $swimming == 1 || $nude == 1\n\t${swapvar} = 2\n\tendif\n "


    # this gets the position override and may cause problems if mods for multiple charters are added as that character will not be detected
    overrides += f"[TextureOverride{name}Position]\n"
    for file in ini_files:
        if file is not None:
            temp = get_position_hash(str(file))
            if temp != ";None found\n":
                overrides += temp
                break
    overrides += "$active = 1\n"

    # adds the necessary if statements into the ini files
    print("Modifying inis...")
    count = 0
    for ini_file in ini_files:
        if ini_file is not None:
            edit_ini(str(ini_file), name, count)
        count += 1
    
    print("Printing results")
    result = f"; Merged Mod: {', '.join([x for x in ini_files if x is not None])}\n\n"
    result += constants
    result += overrides
    result += "\n\n"
    result += "; .ini generated by GIMI (Genshin-Impact-Model-Importer) mod merger script utilizing namespaces\n"
    result += "; If you have any issues or find any bugs dm qwerty3yuiop on discord or leave a comment on game banana"

    with open(f"Master{name}.ini", "w", encoding="utf-8") as f:
        f.write(result)

    print("All operations completed")

# delete script method
def delete_main(root):
    print("\nNamespace Merged Mod Unmerger\n")
    print("\nTHIS SCRIPT WILL DELETE FILES FROM YOUR DEVICE USE WITH CAUTION AND MAKE BACKUPS")
    print("press enter to proceed or enter anything else to exit")
    
    # searches for active files returns if none found
    print("\nSearching for paths containing active inis")
    ini_paths = collect_ini(root, "none")
    if not ini_paths:
        print("Found no .ini files - make sure the mod folders are in the same folder as this script.")
        return
    # lists all found files
    print("\nFound:")
    for i, ini_file in enumerate(ini_paths):
        print(f"\t{i}:  {ini_file}")
    print("All inis displayed above will be deleted and their backups will be restored")
    print("Press enter to proceed with the delete or enter a number to remove a file from the deletion list.")
    userin = input()
    while userin != "":
        try:
            ini_paths.pop(int(userin))
            print(f"\nremoved path number {userin}")
        except:
            print(f"\nUnable to remove {userin} from deletion list")
        finally:
            print("Current Deletion List:")
            for i, ini_file in enumerate(ini_paths):
                print(f"\t{i}:  {ini_file}")
        print("Press enter to proceed with the delete or enter a number to remove a file from the deletion list.")
        userin = input()
    try:
        for file in ini_paths:
            # deletes the file
            os.remove(str(file))
            # renames the backup file
            try:
                rename_file(file)
            except:
                print(f"No back up file found for {file}")
        
        print("All operations completed")
    except:
        print("something went wrong")

# Collects all .ini files from current folder and subfolders
def collect_ini(path, ignore):
    ini_files = []
    for root, dir, files in os.walk(path):
        if "disabled" in root.lower():
            continue
        for file in files:
            if "disabled" in file.lower() or ignore.lower() in file.lower():
                continue
            if os.path.splitext(file)[1] == ".ini":
                ini_files.append(os.path.join(root, file))
    return ini_files

# Gets the user's preferred order to merge mod files
def get_user_order(ini_files):
    # 获取用户输入
    choice = input(f"当前顺序: {', '.join([str(x) for x in range(len(ini_files))])}\n请输入一个数字，将该INI排到最后，按回车保持默认顺序：")

    # 如果用户输入了数字，将对应的ini排到最后
    if choice:
        try:
            index = int(choice)
            if 0 <= index < len(ini_files):
                # 将该ini文件移到最后
                ini_files.append(ini_files.pop(index))
                print(f"将 {ini_files[index]} 移动到最后")
            else:
                print("输入的数字超出范围，保持默认顺序")
        except ValueError:
            print("无效输入，保持默认顺序")
    else:
        print("没有输入，保持默认顺序")

    return ini_files

# Editing existing inis and adding needed text at the end for shader and texture overrides.
def edit_ini(path, name, num):
    with open(path, 'r') as file:
        lines = file.readlines()
    found = False
    count = 0
    max = len(lines)-1
    block = []
    with open(path, 'w') as file:
        for line in lines:
            if found and line.startswith('[') or count == max:
                block.append(line)
                line = comment_fix(block)
                block = []
                found = False
            elif found and line.lower().startswith('match_priority'):
                block.append("")
            elif found:
                line = "\t" + line
                block.append(line)
            elif line.strip().lower().startswith('hash = ') or line.strip().lower().startswith('hash='):
                line = line + f'match_priority = {num}\n' + f'if $\{name}\Master\swapvar=={num}\n'
                found = True
                block.append(line)
            if not found:
                file.write(line)
            count += 1

# makes sure to place the endif immediately after code to be enclosed
def comment_fix(block):
    index = len(block) - 1
    for line in reversed(block):
        if not line.strip().startswith(';') and not line.strip().startswith('[') and not line.strip() == "":
            block[index] = block[index].rstrip()+"\nendif\n\n"
            break
        elif line.strip().startswith(';'):
            block[index] = block[index].lstrip()
        index -= 1
    line = ""
    for x in block:
        line = line + x
    block = []
    return line

# makes a copy of a file that is DISABLED
def generate_backup(file_list):
    for file_path in file_list:
        if file_path is not None:
            dir_name = os.path.dirname(file_path)
            base_name = os.path.basename(file_path)
            new_file_path = os.path.join(dir_name, 'DISABLED' + base_name)
            with open(file_path, 'r') as original_file, open(new_file_path, 'w') as new_file:
                new_file.write(original_file.read())

# finds the position override of a character and returns it
def get_position_hash(path):
    with open(path, 'r') as file:
        lines = file.readlines()
        found = False
        for line in lines:
            if line.startswith('[TextureOverride') and line.endswith('Position]\n'):
                found = True
            if found and (line.strip().lower().startswith('hash = ') or line.strip().lower().startswith('hash=')):
                return line
        return ";None found\n"
    
# renames file
def rename_file(file_path):
    if file_path is not None:
        dir_name = os.path.dirname(file_path)
        base_name = os.path.basename(file_path)
        os.rename(dir_name + '\\DISABLED' + base_name, dir_name + '\\' + base_name)

if __name__ == "__main__":
    main()
